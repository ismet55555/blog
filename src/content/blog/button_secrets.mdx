---
title: 'Big Button - Part 12 - Handling Project Secrets'
description: 'Loading pre-defined configurations for our project'
pubDate: 'Dec 21 2025'
tags: ['big-button', 'embedded', 'rust', 'cargo', 'github', 'config']
draft: true
tech: true
series: {
  name: "Big Button Tutorial",
  order: 12
}
# previousPost:
#   slug: "button_rust_dev_workflow"
#   title: "Development Workflow"
# nextPost: 
#   slug: "button_rust_project_configuration"
#   title: "Rust Project Configuration"
aiHelp: [
  '8-bit style images - Dall-e (ChatGPT)',
  'Really explain specific file content - Claude',
  'Spelling and grammar suggestions - Claude',
  'General post-hoc review - Claude'
]
---
import Figure from '../../components/Figure.astro'
import Tag from '../../components/Tag.astro'
import crabGearWrench from '../../images/button/configs/crab_gear_wrench.webp';
import tba from '../../images/tba.png';

## Table of Contents

## Introduction

TODO: FIX ALL HERE

<Tag color="green" txt="ðŸ’» HACKER" />
Once we start adding all kinds of code, logic, and structure to our
project, it will quickly become evident that we need some type of
clear and centralized way of controlling configurations, settings, options,
parameters, or [sensitive secrets](https://youtu.be/3fpN-1kPcDE?si=ENCac5XqLFYZ5_rv).
That is, it becomes inefficient, annoying, and un-maintainable to [hardcode](https://en.wikipedia.org/wiki/Hard_coding)
contants directly into the code at very specific locations.

<Figure
  src={crabGearWrench}
  caption="Happy to be able to easily configure a embedded project"
  url="https://youtu.be/JOLtS4VUcvQ?si=K40hQLdXb4fvDa_L"
/>

Let's consider the following code example of a super simple snippet
of Rust code that that contrasts using a hardcoded value and one
that does not.

```rust title="example-simple-config-usage.rs"
// Example using a constnat that is hardcoded
let mut iteration_count = 0;
while iteration_count < 5 {
  iteration_count += 1;
}

// Example using a constant from configurations
let mut iteration_count = 0;
while iteration_count < MAX_ITERATION_COUNT {
  iteration_count += 1;
}
```

In one instance we are hardcoding the number `5` into our code,
while in the second instance we are pulling a constant `MAX_ITERATION_COUNT`
from a central configuraiton file. Which one do you think is more
maintainable in the long run?

## Secrets

- Explain reasoning behind our approach and considerations for real systems
- Explain concept of OTP memory and storing encryption keys then decrypting secrets

  - see below

- Add line to `.gitignore`

- Add `secrets.json`

<Aside variant="warning">
  Secrets are secret and not for GitHub!
</Aside>

## Documentation

- Update `README.md` on how to use `configs.json` and `secrets.json`



```sh title="TODO
todo blah.sh
```

<span class="text-accentColor font-bold">
  Sweet, .....
</span>


## ðŸ“‹ Brief Summary: OTP Encryption Key Approach

### One-Time Setup (Per Device):
â€¢ **Generate & Store Key**: Flash a provisioning binary that generates a random 32-byte AES-256
  key and writes it to OTP page 32 (permanent, one-time only)

â€¢ **Read Key Once**: Use a debug program to read the key from OTP and save it for your 
  encryption tool

### Development Workflow:
â€¢ **Create Secrets**: Write your `secrets.json` with WiFi passwords, API keys, etc. (gitignored)

â€¢ **Encrypt Secrets**: Run a host-side tool that uses the OTP key to AES-encrypt `secrets.json` 
  â†’ `encrypted_secrets.json` (safe to commit)

â€¢ **Build Firmware**: `build.rs` embeds the encrypted secrets as constants in your binary

â€¢ **Runtime Decryption**: Main app reads the encryption key from OTP, then decrypts the secrets 
  in memory when needed

### To Update Secrets:
â€¢ Change `secrets.json` â†’ Re-encrypt â†’ Commit new `encrypted_secrets.json` â†’ Deploy firmware

### Key Benefits:
â€¢ **Hardware-protected** encryption key (in OTP)
â€¢ **Updateable** secrets (just re-encrypt and deploy)  
â€¢ **Git-safe** encrypted file can be committed
â€¢ **Unique per device** (each has its own key)
â€¢ **No plaintext** secrets in firmware binary

That's it! One permanent key in OTP unlocks updateable encrypted secrets.
